/* Copyright (C)
* 2015 - John Melton, G0ORX/N6LYT
* 2025 - Christoph van WÃ¼llen, DL1YCF
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see <https://www.gnu.org/licenses/>.
*
*/

#include <gtk/gtk.h>

#include "actions.h"
#include "gpio.h"
#include "message.h"
#include "property.h"
#include "radio.h"
#include "toolbar.h"

int tb_function[MAX_TB_ROWS] = {0, 1, 2};
enum ACTION tb_actions[MAX_TB_FUNCTIONS][MAX_TB_BUTTONS] = {
  { MOX,   TUNE,           TWO_TONE,       MENU_NOISE, MENU_BAND,   MENU_MODE,  MENU_FILTER, FUNCTION },
  { SPLIT, MENU_BANDSTACK, CTUN,           RIT_PLUS,   RIT_MINUS,   XIT_PLUS,   XIT_MINUS,   FUNCTION },
  { MOX,   LOCK,           DUPLEX,         A_TO_B,     B_TO_A,      A_SWAP_B,   SPLIT,       FUNCTION },
  { MOX,   MENU_FREQUENCY, SPLIT,          DUPLEX,     SAT,         RSAT,       MENU_BAND,   FUNCTION },
  { MOX,   MENU_FREQUENCY, MENU_MEMORY,    RIT_ENABLE, RIT_PLUS,    RIT_MINUS,  RIT_CLEAR,   FUNCTION },
  { MOX,   MENU_FREQUENCY, MENU_MEMORY,    XIT_ENABLE, XIT_PLUS,    XIT_MINUS,  XIT_CLEAR,   FUNCTION }
};

static GtkWidget *toolbar_grid = NULL;

static GtkWidget *tbbtn[8][3] = { { NULL }};

void toolbar_save_state() {
  for (int i = 0; i < MAX_TB_ROWS; i++) {
    SetPropI1("toolbar.row[%d]", i, tb_function[i]);
  }

  for (int f = 0; f < MAX_TB_FUNCTIONS; f++) {
    for (int i = 0; i < MAX_TB_BUTTONS; i++) {
      SetPropA2("toolbar[%d,%d].action", f, i, tb_actions[f][i]);
    }
  }
}

void toolbar_restore_state() {
  for (int i = 0; i < MAX_TB_ROWS; i++) {
    GetPropI1("toolbar.row[%d]", i, tb_function[i]);
  }

  for (int f = 0; f < MAX_TB_FUNCTIONS; f++) {
    for (int i = 0; i < MAX_TB_BUTTONS; i++) {
      GetPropA2("toolbar[%d,%d].action", f, i, tb_actions[f][i]);
    }
  }
}

void update_toolbar_labels() {
  for (int i = 0; i < MAX_TB_ROWS; i++) {
    int func = tb_function[i];

    for (int j = 0; j < MAX_TB_BUTTONS; j++) {
      GtkWidget *btn = tbbtn[j][i];

      if (btn) {
        if (j == MAX_TB_BUTTONS - 1) {
          char lbl[16];
          snprintf(lbl, sizeof(lbl), "FNC(%d)", tb_function[i]);
          gtk_button_set_label(GTK_BUTTON(btn), lbl);
        } else {
          gtk_button_set_label(GTK_BUTTON(btn),
                               ActionTable[tb_actions[func][j]].button_str);
        }
      }
    }
  }
}

// cppcheck-suppress constParameterCallback
static void toolbar_button_press_cb(GtkWidget *widget, GdkEventButton *event, gpointer data) {
  int val = GPOINTER_TO_INT(data);
  int btn = val % 100;
  int row = val / 100;

  //
  // Filter out any special events generated by double or triple clicks
  //
  if (event->type != GDK_BUTTON_PRESS) { return; }

  //
  // We have to implement the function key "manually" here, since the
  // "action" only refers to row zero.
  //
  if (btn == MAX_TB_BUTTONS - 1) {
    //
    // This is our "easter egg" for the FUNC toolbar button. A secondary (right) click
    // cycles backwards.
    //
    if (event->button == GDK_BUTTON_SECONDARY) {
      tb_function[row]--;

      if (tb_function[row] < 0) { tb_function[row] = MAX_TB_FUNCTIONS - 1; }
    } else {
      tb_function[row]++;

      if (tb_function[row] >= MAX_TB_FUNCTIONS) { tb_function[row] = 0; }
    }

    update_toolbar_labels();
  } else {
    schedule_action(tb_actions[tb_function[row]][btn], PRESSED, 0);
  }
}

// cppcheck-suppress constParameterCallback
static void toolbar_button_released_cb(GtkWidget *widget, GdkEventButton *event, gpointer data) {
  int val = GPOINTER_TO_INT(data);
  int btn = val % 100;

  if (btn != MAX_TB_BUTTONS - 1) {
    int row = val / 100;
    schedule_action(tb_actions[tb_function[row]][btn], RELEASED, 0);
  }
}

void toolbar_show(int ypos) {
  if (toolbar_grid) {
    gtk_fixed_put(GTK_FIXED(fixed),  toolbar_grid, 0, ypos);
    gtk_widget_show_all(toolbar_grid);
  }
}

void toolbar_destroy() {
  if (toolbar_grid) {
    gtk_container_remove(GTK_CONTAINER(fixed), toolbar_grid);
    toolbar_grid = NULL;

    for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 8; j++) {
        tbbtn[j][i] = NULL;
      }
    }
  }
}

void toolbar_create(int width, int height, int rows) {
  int button_width = width / 8;
  const char *button_css;
  t_print("%s: width=%d height=%d button_width=%d\n", __FUNCTION__, width, height, button_width);

  if (height < 40) {
    button_css = "small_button";
  } else if (height < 50) {
    button_css = "medium_button";
  } else {
    button_css = "large_button";
  }

  toolbar_destroy();
  toolbar_grid = gtk_grid_new();
  gtk_widget_set_size_request (toolbar_grid, width, rows * height);
  gtk_grid_set_column_homogeneous(GTK_GRID(toolbar_grid), TRUE);
  gtk_grid_set_row_homogeneous(GTK_GRID(toolbar_grid), TRUE);

  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < 8; j++) {
      GtkWidget *w = gtk_button_new();
      gpointer code = GINT_TO_POINTER(100 * i + j);
      gtk_widget_set_name(w, button_css);
      gtk_widget_set_size_request (w, button_width, height);
      g_signal_connect(G_OBJECT(w), "button-press-event", G_CALLBACK(toolbar_button_press_cb), code);
      g_signal_connect(G_OBJECT(w), "button-release-event", G_CALLBACK(toolbar_button_released_cb), code);
      gtk_grid_attach(GTK_GRID(toolbar_grid), w, 4 * j, rows - i - 1, 4, 1);
      tbbtn[j][i] = w;
    }
  }

  update_toolbar_labels();
}
